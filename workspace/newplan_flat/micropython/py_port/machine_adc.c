/*
 * machine_adc.c - RA8D1 ADC Implementation using FSP driver
 *
 * Created on: 2025
 * Author: Embedded Systems Engineer
 */

#include "py/runtime.h"
#include "py/mphal.h"
#include "hal_data.h"
#include "bsp_api.h"
#include "machine_pin.h"
#include "machine_adc.h"
#include "r_adc_api.h"  // For ADC API types and constants

// Define STATIC macro
#ifndef STATIC
#define STATIC static
#endif

// Helper macro for manual analog pin configuration
// Use R_BSP_PinAccessEnable/Disable for PFS register access
#define RA_SETUP_ANALOG_PIN(port, pin) \
    do { \
        R_BSP_PinAccessEnable(); \
        R_PFS->PORT[port].PIN[pin].PmnPFS_b.PMR = 0; \
        R_PFS->PORT[port].PIN[pin].PmnPFS_b.ASEL = 1; \
        R_BSP_PinAccessDisable(); \
    } while(0)

// ADC instances are defined in hal_data.h (generated by FSP)
// g_adc0 (Unit 0) and g_adc1 (Unit 1) are already declared in hal_data.h

// Track which ADC units are open (lazy initialization)
static bool g_adc0_open = false;
static bool g_adc1_open = false;

// Pin to ADC channel mapping structure
typedef struct {
    bsp_io_port_pin_t pin;
    uint8_t unit;           // ADC unit (0 or 1)
    uint8_t channel;        // ADC channel number
    bool needs_manual_cfg;  // True for P014/P015
} pin_adc_map_t;

// Pin to ADC channel mapping table
static const pin_adc_map_t pin_adc_map[] = {
    // ADC Unit 0 channels
    {BSP_IO_PORT_00_PIN_04, 0, 0, false},   // P004 -> AN000
    {BSP_IO_PORT_00_PIN_05, 0, 1, false},   // P005 -> AN001
    {BSP_IO_PORT_00_PIN_06, 0, 2, false},   // P006 -> AN002
    {BSP_IO_PORT_00_PIN_07, 0, 4, false},   // P007 -> AN004
    {BSP_IO_PORT_00_PIN_10, 0, 5, false},   // P010 -> AN005
    {BSP_IO_PORT_00_PIN_09, 0, 6, false},   // P009 -> AN006
    {BSP_IO_PORT_00_PIN_14, 0, 7, true},    // P014 -> AN007 (needs manual config)
    
    // ADC Unit 1 channels
    {BSP_IO_PORT_00_PIN_03, 1, 4, false},   // P003 -> AN104
    {BSP_IO_PORT_00_PIN_11, 1, 6, false},   // P011 -> AN106
    {BSP_IO_PORT_00_PIN_15, 1, 5, true},    // P015 -> AN105 (needs manual config)
};

#define PIN_ADC_MAP_SIZE (sizeof(pin_adc_map) / sizeof(pin_adc_map_t))

// Find ADC channel for a given pin
static const pin_adc_map_t *find_adc_channel(bsp_io_port_pin_t pin_id) {
    for (size_t i = 0; i < PIN_ADC_MAP_SIZE; i++) {
        if (pin_adc_map[i].pin == pin_id) {
            return &pin_adc_map[i];
        }
    }
    return NULL;
}

// Get pin ID from Python object (Pin object or string)
static bsp_io_port_pin_t get_pin_id_from_obj(mp_obj_t pin_in) {
    // Check if it's a Pin object
    if (mp_obj_is_type(pin_in, &ra_pin_type)) {
        ra_pin_obj_t *pin_obj = MP_OBJ_TO_PTR(pin_in);
        return pin_obj->pin_id;
    }
    
    // Check if it's a string like "P014"
    if (mp_obj_is_str(pin_in)) {
        size_t len;
        const char *str = mp_obj_str_get_data(pin_in, &len);
        
        // Parse "P014" format: P + port (2 digits) + pin (2 digits)
        if (len >= 4 && str[0] == 'P') {
            int port = 0, pin = 0;
            if (len == 4) {
                // P014 format: P + 0 + 14
                port = (str[1] - '0') * 10 + (str[2] - '0');
                pin = (str[3] - '0') * 10 + (str[4] - '0');
            } else if (len == 5) {
                // P014 format: P + 0 + 1 + 4
                port = (str[1] - '0') * 10 + (str[2] - '0');
                pin = (str[3] - '0') * 10 + (str[4] - '0');
            }
            
            if (port >= 0 && port <= 15 && pin >= 0 && pin <= 15) {
                return (bsp_io_port_pin_t)((port << 8) | pin);
            }
        }
    }
    
    // Try as integer (direct pin ID)
    mp_int_t pin_id_int = mp_obj_get_int(pin_in);
    return (bsp_io_port_pin_t)pin_id_int;
}

// Lazy initialization of ADC unit
static fsp_err_t adc_unit_open(uint8_t unit) {
    const adc_instance_t *instance = (unit == 0) ? &g_adc0 : &g_adc1;
    bool *is_open = (unit == 0) ? &g_adc0_open : &g_adc1_open;
    
    if (*is_open) {
        return FSP_SUCCESS;  // Already open
    }
    
    fsp_err_t err = instance->p_api->open(instance->p_ctrl, instance->p_cfg);
    if (err == FSP_SUCCESS) {
        *is_open = true;
    }
    
    return err;
}

// ========== ADC Object Implementation ==========

static void adc_obj_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    ra_adc_obj_t *self = MP_OBJ_TO_PTR(self_in);
    mp_printf(print, "ADC(unit=%u, channel=%u)", self->unit, self->channel);
}

// Constructor: ADC(pin)
static mp_obj_t adc_obj_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    // Parse arguments
    enum { ARG_id };
    static const mp_arg_t allowed_args[] = {
        { MP_QSTR_id, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },
    };
    
    mp_arg_val_t vals[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all_kw_array(n_args, n_kw, args, MP_ARRAY_SIZE(allowed_args), allowed_args, vals);
    
    // Get pin ID
    bsp_io_port_pin_t pin_id = get_pin_id_from_obj(vals[ARG_id].u_obj);
    
    // Find ADC channel mapping
    const pin_adc_map_t *map = find_adc_channel(pin_id);
    if (map == NULL) {
        mp_raise_msg_varg(&mp_type_ValueError,
                         MP_ERROR_TEXT("Pin 0x%04X is not a valid ADC pin"),
                         (unsigned int)pin_id);
    }
    
    // Create ADC object
    ra_adc_obj_t *self = m_new_obj(ra_adc_obj_t);
    self->base.type = type;
    self->unit = map->unit;
    self->channel = map->channel;
    self->is_open = false;
    self->adc_instance = (map->unit == 0) ? &g_adc0 : &g_adc1;
    
    // Manual pin configuration for P014/P015
    if (map->needs_manual_cfg) {
        uint8_t port = (pin_id >> 8) & 0xFF;
        uint8_t pin = pin_id & 0xFF;
        RA_SETUP_ANALOG_PIN(port, pin);
    }
    
    // Lazy initialization of ADC unit
    fsp_err_t err = adc_unit_open(self->unit);
    if (err != FSP_SUCCESS) {
        mp_raise_msg_varg(&mp_type_RuntimeError,
                         MP_ERROR_TEXT("Failed to open ADC unit %u: %d"),
                         self->unit, err);
    }
    
    return MP_OBJ_FROM_PTR(self);
}

// read_u16() - Read ADC value and scale to 16-bit
static mp_obj_t adc_obj_read_u16(mp_obj_t self_in) {
    ra_adc_obj_t *self = MP_OBJ_TO_PTR(self_in);
    
    // Ensure ADC unit is open
    fsp_err_t err = adc_unit_open(self->unit);
    if (err != FSP_SUCCESS) {
        mp_raise_msg_varg(&mp_type_RuntimeError,
                         MP_ERROR_TEXT("Failed to open ADC unit %u: %d"),
                         self->unit, err);
    }
    
    // Create a copy of channel config to modify scan_mask
    // scan_mask is in adc_channel_cfg_t, not adc_cfg_t
    // p_channel_cfg is void const *, need to cast to adc_channel_cfg_t const *
    adc_channel_cfg_t const *p_channel_cfg = (adc_channel_cfg_t const *)self->adc_instance->p_channel_cfg;
    adc_channel_cfg_t channel_cfg_shadow = *p_channel_cfg;
    
    // Add the channel to scan_mask if not already present
    // For P014 (Unit 0, Channel 7) or P015 (Unit 1, Channel 5), these are not in the default scan_mask
    // For other channels, they should already be in scan_mask, but we ensure it anyway
    uint32_t channel_bit;
    switch (self->channel) {
        case 0: channel_bit = ADC_MASK_CHANNEL_0; break;
        case 1: channel_bit = ADC_MASK_CHANNEL_1; break;
        case 2: channel_bit = ADC_MASK_CHANNEL_2; break;
        case 3: channel_bit = ADC_MASK_CHANNEL_3; break;
        case 4: channel_bit = ADC_MASK_CHANNEL_4; break;
        case 5: channel_bit = ADC_MASK_CHANNEL_5; break;
        case 6: channel_bit = ADC_MASK_CHANNEL_6; break;
        case 7: channel_bit = ADC_MASK_CHANNEL_7; break;
        default: channel_bit = (1UL << self->channel); break;  // Fallback for channels > 7
    }
    channel_cfg_shadow.scan_mask |= channel_bit;
    
    // Configure scan (this may need to be done each time if channel changes)
    // scanCfg expects adc_channel_cfg_t pointer as p_extend parameter
    err = self->adc_instance->p_api->scanCfg(self->adc_instance->p_ctrl, &channel_cfg_shadow);
    if (err != FSP_SUCCESS) {
        mp_raise_msg_varg(&mp_type_RuntimeError,
                         MP_ERROR_TEXT("Failed to configure ADC scan: %d"), err);
    }
    
    // Start scan
    err = self->adc_instance->p_api->scanStart(self->adc_instance->p_ctrl);
    if (err != FSP_SUCCESS) {
        mp_raise_msg_varg(&mp_type_RuntimeError,
                         MP_ERROR_TEXT("Failed to start ADC scan: %d"), err);
    }
    
    // Wait for scan completion (blocking)
    adc_status_t status;
    uint32_t timeout = 200;  // 1 second timeout
    uint32_t start_time = mp_hal_ticks_ms();
    
    do {
        err = self->adc_instance->p_api->scanStatusGet(self->adc_instance->p_ctrl, &status);
        if (err != FSP_SUCCESS) {
            mp_raise_msg_varg(&mp_type_RuntimeError,
                             MP_ERROR_TEXT("Failed to get ADC status: %d"), err);
        }
        
        if ((mp_hal_ticks_ms() - start_time) > timeout) {
            mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT("ADC scan timeout"));
        }
        
        MICROPY_EVENT_POLL_HOOK
    } while (status.state != ADC_STATE_IDLE);
    
    // Read result
    // read() function uses adc_channel_t type, not uint8_t
    uint16_t adc_value;
    adc_channel_t adc_channel = (adc_channel_t)self->channel;
    err = self->adc_instance->p_api->read(self->adc_instance->p_ctrl, adc_channel, &adc_value);
    if (err != FSP_SUCCESS) {
        mp_raise_msg_varg(&mp_type_RuntimeError,
                         MP_ERROR_TEXT("Failed to read ADC channel %u: %d"),
                         self->channel, err);
    }
    
    // Scale from 12-bit (0-4095) to 16-bit (0-65535)
    uint16_t scaled_value = (uint16_t)(((uint32_t)adc_value * 65535) / 4095);
    
    return mp_obj_new_int_from_uint(scaled_value);
}
static MP_DEFINE_CONST_FUN_OBJ_1(adc_obj_read_u16_obj, adc_obj_read_u16);

// ADC class methods dictionary
static const mp_rom_map_elem_t adc_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_read_u16), MP_ROM_PTR(&adc_obj_read_u16_obj) },
};
static MP_DEFINE_CONST_DICT(adc_locals_dict, adc_locals_dict_table);

// ADC type definition
MP_DEFINE_CONST_OBJ_TYPE(
    ra_adc_type,
    MP_QSTR_ADC,
    MP_TYPE_FLAG_NONE,
    make_new, adc_obj_make_new,
    print, adc_obj_print,
    locals_dict, &adc_locals_dict
);

