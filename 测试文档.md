# MicroPython RA8D1 移植功能验证测试报告

本报告包含针对 GPIO、中断、I2C、SPI、系统时钟等核心功能的测试用例。每个用例旨在验证特定硬件外设的驱动实现是否正确及稳定。

### 1、LED 闪烁与按键控制测试

**目的**：验证 GPIO 的基本 **输出（Output）** 和 **输入（Input）** 功能，以及 **上拉电阻（Pull-Up）** 的配置是否生效

**测试代码逻辑**：LED1 自动闪烁，按下按键 SW2 时熄灭 LED2

```python
import machine
import utime

# --- 引脚定义 ---
PIN_LED1 = 0x0600  # P600 (LED1)
PIN_LED2 = 0x0107  # P107 (LED2)
PIN_SW2  = 0x0008  # P008 (用户按键 SW2)

def run_demo():
    print("Initializing Expansion Board Demo... ")
    
    # 初始化 LED 为输出模式
    led1 = machine.Pin(PIN_LED1, machine.Pin.OUT)
    led2 = machine.Pin(PIN_LED2, machine.Pin.OUT)
    
    # 初始化按键为输入模式，并开启内部上拉电阻
    # 注意：如果不开启上拉，悬空引脚可能读取到随机值
    sw2 = machine.Pin(PIN_SW2, machine.Pin.IN, machine.Pin.PULL_UP)
    
    print("Press SW2 (Key 2) to toggle LED2. LED1 will blink automatically.")
    print("Press Ctrl+C to exit.")
    
    led1_state = 0
    try:
        while True:
            # --- 逻辑 1: LED1 自动闪烁 ---
            led1_state = not led1_state
            led1.value(led1_state)
            
            # --- 逻辑 2: 按键控制 LED2 ---
            # value() == 0 表示按键按下（接地），因为配置了上拉
            if sw2.value() == 0:  
                led2.on()  # 点亮 LED2
                print("Button Pressed!")
            else:
                led2.off() # 熄灭 LED2
            
            # 延时 100ms
            utime.sleep_ms(100)
            
    except KeyboardInterrupt:
        # 捕获 Ctrl+C，关闭 LED 并退出
        led1.off()
        led2.off()
        print("\nDemo stopped.")

if __name__ == "__main__":
    run_demo()
```

### 2、GPIO 推挽与开漏输出模式验证

**目的**：验证 GPIO 在 **推挽（Push-Pull）** 和 **开漏（Open-Drain）** 模式下的电气特性。重点测试开漏模式下输出高电平时是否呈现高阻态（需外部或内部上拉才能测得高电平），确保驱动配置正确写入寄存器

```python
"""
MicroPython RA8D1 - Pin OPEN_DRAIN Mode Test
测试引脚: P410 (Arduino D12, ID=0x040A)
"""

from machine import Pin
import utime

PIN_P410 = 0x040A

print("=" * 60)
print("MicroPython RA8D1 - Pin OPEN_DRAIN Mode Test")
print("=" * 60)
print("Target Pin: P410 (ID: 0x{:04X})".format(PIN_P410))
print()
print("INSTRUCTIONS :")
print("1. Prepare a multimeter (Voltage mode). ")
print("2. Connect Black probe to GND. ")
print("3. Connect Red probe to P410. ")
print("-" * 60)

# --- 测试 1: 推挽输出模式 ---
print()
print("[Test 1] Push-Pull Output Mode ")
print("-" * 60)
pin_pp = Pin(PIN_P410, Pin.OUT)

print("Setting HIGH (1)... ")
pin_pp.value(1)
print("EXPECTED: ~3.3V") # 预期测量值
print("ACTION: Please measure now. ")
utime.sleep_ms(5000)

print("Setting LOW (0)... ")
pin_pp.value(0)
print("EXPECTED: ~0V")
print("ACTION: Please measure now.")
utime.sleep_ms(5000)

print("Setting HIGH (1) again...")
pin_pp.value(1)
print("Status: Pin driven HIGH actively. ")
utime.sleep_ms(5000)

# --- 测试 2: 开漏模式 (无上拉) ---
print()
print("[Test 2] Open-Drain Mode (Pin.OPEN_DRAIN) - NO External Pull-up")
print("-" * 60)
# 初始化为开漏模式，无内部上拉
pin_od = Pin(PIN_P410, Pin.OPEN_DRAIN)

print(">>> Setting LOW (0)...")
pin_od.value(0)
print("    EXPECTED: ~0V (Active Low - NMOS)")
utime.sleep_ms(5000)

print(">>> Setting HIGH (1)...")
pin_od.value(1)
print("    EXPECTED: Floating / ~0V (High-Z)")
print("    NOTE: Without pull-up, voltage is NOT 3.3V.")
utime.sleep_ms(5000)

# --- 测试 3: 开漏模式 (带内部上拉) ---
print()
print("[Test 3] Open-Drain Mode with Internal Pull-up") #  开漏模式 + 内部上拉
print("-" * 60)
# 重新初始化：开漏 + 内部上拉
pin_od_pullup = Pin(PIN_P410, Pin.OPEN_DRAIN, Pin.PULL_UP)

print(">>> Setting LOW (0)...")
pin_od_pullup.value(0)
print("    EXPECTED: ~0V (Strong override )") # 强下拉覆盖上拉
utime.sleep_ms(5000)

print(">>> Setting HIGH (1)...")
pin_od_pullup.value(1)
print("    EXPECTED: ~3.3V (Provided by internal resistor)") # 内部电阻提供高电平
utime.sleep_ms(5000)

print()
print("=" * 60)
print("Test Finished.")
print("=" * 60)
```

### 3、中断功能测试

#### 3.1： 基础中断触发与回调测试 

**目的**：验证 GPIO **下降沿（Falling Edge）** 中断能否正确触发 Python 回调函数。此测试直接在回调中操作硬件（翻转 LED），用于验证中断响应的最简路径

```python
from machine import Pin
import utime

print("=== IRQ Toggle Test ===")

# 初始化 LED (P1001 / 0x0A01) 为输出
led = Pin(0x0A01, Pin.OUT)
led.on()

# 初始化按键 (P008) 为输入，带上拉
p = Pin(0x0008, Pin.IN, Pin.PULL_UP)

# --- 中断回调函数 ---
def irq_handler(pin):
    # 在中断中翻转 LED 状态
    # 注意：尽量避免在中断中使用 print()，可能导致死锁或堆栈溢出
    led.value(not led.value()) 

# 配置中断：下降沿触发 (按下按键)
p.irq(handler=irq_handler, trigger=Pin.IRQ_FALLING)

while True:
    utime.sleep_ms(1000)
```

irq_handler函数内不能有print()函数，程序会卡在Default_Handler()

原因：**死锁 (Deadlock)**：在中断回调中使用了 `print()` ，导致 UART 试图在中断里等待传输完成，但因为优先级问题永远等不到。

结果：

```python
按下按键，核心板LED随之开关
```



#### 3.2： 中断标志位处理模式测试

**目的**：验证中断编程模式—**ISR（中断服务程序）只设置标志位，主循环处理业务逻辑**。这种方法可以安全地使用 `print()` 等耗时或阻塞函数，避免在中断上下文中发生死锁

```python
from machine import Pin, LED
import utime

# 初始化 LED 和 按键
led = LED(1) 
p = Pin(0x0008, Pin.IN, Pin.PULL_UP)

# 全局变量：用于中断与主循环通信
irq_flag = False
irq_count = 0

# --- 优化的中断回调 ---
def irq_handler(pin):
    global irq_flag, irq_count
    led.toggle()    # 快速操作硬件
    irq_flag = True # 仅设置标志位，立即退出
    irq_count += 1

# 配置中断：下降沿触发
p.irq(handler=irq_handler, trigger=Pin.IRQ_FALLING)

print("Press button...")

# --- 主循环 ---
while True:
    # 检查标志位
    if irq_flag:
        # 在主线程中安全地执行耗时操作 (如打印)
        print("Press count: {}".format(irq_count))
        irq_flag = False # 清除标志位
        
    utime.sleep_ms(100)
```

输出：

```python
(base) PS C:\Users\demon\Desktop\MPY-test> mpremote connect COM10 run demo.py
Press button...
Press count: 1
Press count: 2
Press count: 3
Press count: 4
Press count: 5
Press count: 6
Press count: 7
Press count: 8
Press count: 9
Press count: 10
```



#### 3.3：GPIO 中断扩展测试 

**目的**：验证 FSP 驱动对不同触发模式的支持，包括 **上升沿 (Rising)** 和 **双边沿 (Both)**。确保驱动能够正确配置 ICU/GPIO 寄存器，且没有漏触发或误触发

```python
"""
Test GPIO IRQ - Rising and Both Edges
测试 GPIO 中断 - 上升沿与双边沿
Pin: P008 (User Button)
"""
import machine
import utime
from machine import Pin

# 全局计数器
rising_count = 0
both_count = 0

# 上升沿回调
def rising_handler(pin):
    global rising_count
    rising_count += 1
    
# 双边沿回调
def both_handler(pin):
    global both_count
    both_count += 1

def run_irq_test():
    global rising_count, both_count
    
    # 初始化按键
    btn = Pin(0x0008, Pin.IN, Pin.PULL_UP)
    
    print("=" * 40)
    print("GPIO IRQ Extended Test")
    print("=" * 40)
    
    # --- 测试 1: 上升沿检测 (松开按键触发) ---
    print("\n[Test 1] RISING Edge Detection")
    print("INSTRUCTION: Press and HOLD, then RELEASE the button.")
    
    # 配置中断：上升沿
    btn.irq(handler=rising_handler, trigger=Pin.IRQ_RISING)
    
    last_count = rising_count
    for i in range(5):
        current = rising_count
        if current > last_count:
            print("  Rising edge detected! Count: {}".format(current))
            last_count = current
        utime.sleep_ms(1000) # 这里的延时应适当缩短以提高响应感，比如改为 200ms 并在循环中更多次检测
    
    # 禁用中断
    btn.irq(handler=None) 
    print("Test 1 Finished. Total Rising Edges: {}".format(rising_count))

    # --- 测试 2: 双边沿检测 (按下和松开均触发) ---
    print("\n[Test 2] BOTH Edges Detection ")
    print("INSTRUCTION: Press and Release the button multiple times.")
    
    # 配置中断：双边沿 (通常定义为 3)
    TRIGGER_BOTH = 3 
    try:
        btn.irq(handler=both_handler, trigger=TRIGGER_BOTH)
    except Exception as e:
        print("Error setting BOTH trigger: {}".format(e))
        return

    last_count = both_count
    for i in range(10):
        current = both_count
        if current > last_count:
            # 读取当前电平推测触发边沿
            state = "High (Rising)" if btn.value() else "Low (Falling)"
            print("  Edge detected! Pin is {}, Count: {}".format(state, current))
            last_count = current
        utime.sleep_ms(500)
        
    btn.irq(handler=None)
    print("Test 2 Finished. Total Both Edges: {}".format(both_count))

if __name__ == "__main__":
    run_irq_test()
```

输出：

```python
========================================
GPIO IRQ Extended Test
========================================

[Test 1] RISING Edge Detection
INSTRUCTION: Press and HOLD, then RELEASE the button.
	Rising edge detected! Count: 1
	Rising edge detected! Count: 3
	Rising edge detected! Count: 8
Test 1 Finished. Total Rising Edges: 10

[Test 2] BOTH Edges Detection
INSTRUCTION: Press and Release the button multiple times.
	Edge detected! Pin is Low, Count: 3
	Edge detected! Pin is High, Count: 6
	Edge detected! Pin is High, Count: 16
	Edge detected! Pin is High, Count: 22
	Edge detected! Pin is High, Count: 26
	Edge detected! Pin is High, Count: 32
	Edge detected! Pin is High, Count: 39
Test 2 Finished. Total Both Edges: 53
```



### 4、I2C测试

连接磁力计：

| **传感器模块引脚 (Sensor)** | **所在排针 (Header)** | **开发板引脚 (RA8D1 Board)** | **说明**                               |
| --------------------------- | --------------------- | ---------------------------- | -------------------------------------- |
| **3V3** (VCC)               | CN2 - Pin 1           | **3.3V**                     | 电源正极                               |
| **GND**                     | CN2 - Pin 2           | **GND**                      | 电源地                                 |
| **SCL**                     | CN2 - Pin 4           | **P512** (SCL1)              | I2C 时钟线                             |
| **SDA**                     | CN2 - Pin 5           | **P511** (SDA1)              | I2C 数据线                             |
| **2 CS** (LIS2MDL 片选)     | **CN1 - Pin 2**       | **3.3V**                     | **关键！** 必须接高电平以启用 I2C 模式 |
| **1 CS** (LSM6DSV 片选)     | CN1 - Pin 6           | **3.3V**                     | **关键！** 必须接高电平以启用 I2C 模式 |

#### 4.1： I2C 总线设备扫描测试：

**目的**：验证 I2C 硬件控制器能否正确发送地址并在总线上检测到 ACK 响应

```python
from machine import I2C
import utime

# 等待上电稳定
utime.sleep_ms(1000)

# 初始化 I2C1, 频率 100kHz
i2c = I2C(1, freq=100000) 

print("Scanning I2C bus...")
utime.sleep_ms(1000)

# 执行扫描，返回设备地址列表 (十进制)
devices = i2c.scan()
utime.sleep_ms(1000)

print("Scan result (devices found):", devices)
# 预期输出: [30, 107] 对应 0x1E (磁力计) 和 0x6B (六轴)
```

```python
输出：
scaning...
result: [30, 107]
```

#### 4.2： I2C 传感器初始化与数据读取：

 **目的**：验证驱动能否正确执行 **寄存器写入 (writeto_mem)** 和 **寄存器读取 (readfrom_mem)** 操作，并正确解析多字节数据（如加速度、角速度）

```python
import machine
import utime
import gc

# --- I2C 配置参数 ---
I2C_ID = 1           # 使用 IIC1 通道
I2C_FREQ = 100000    # 频率 100kHz (为了稳定性，杜邦线连接建议不要太高)

# --- 设备地址 (7-bit) ---
ADDR_MAG = 0x1E      # LIS2MDL 磁力计地址
ADDR_IMU = 0x6B      # LSM6DSV16X 六轴传感器地址 (SDO接电源时为0x6B)

# --- 寄存器地址定义 ---
# 磁力计寄存器
REG_MAG_CFG_A    = 0x60  # 配置寄存器 A (控制模式和速率)
REG_MAG_CFG_C    = 0x62  # 配置寄存器 C (控制数据保护 BDU)
REG_MAG_OUT_X_L  = 0x68  # 输出数据起始地址 (X低字节)

# 六轴传感器寄存器
REG_IMU_CTRL1_XL = 0x10  # 加速度计控制寄存器
REG_IMU_CTRL2_G  = 0x11  # 陀螺仪控制寄存器
REG_IMU_OUTX_L_G = 0x22  # 角速度输出起始地址
REG_IMU_OUTX_L_A = 0x28  # 加速度输出起始地址

print("=== START DEBUG (调试开始) ===")

def init_sensors(i2c):
    """初始化传感器，唤醒芯片并设置采样率"""
    print("[1] Init Sensors...")
    try:
        # --- 配置六轴 (LSM6DSV16X) ---
        # 写入 0x03 (二进制 0011) -> ODR = 15Hz, 开启高性能模式
        i2c.writeto_mem(ADDR_IMU, REG_IMU_CTRL1_XL, b'\x03') # 唤醒加速度计
        i2c.writeto_mem(ADDR_IMU, REG_IMU_CTRL2_G, b'\x03')  # 唤醒陀螺仪
        
        # --- 配置磁力计 (LIS2MDL) ---
        # 写入 0x00 -> 连续测量模式 (Continuous mode), ODR = 10Hz
        i2c.writeto_mem(ADDR_MAG, REG_MAG_CFG_A, b'\x00') 
        # 写入 0x10 -> 开启 BDU (Block Data Update)，防止读取时数据更新导致高低位错乱
        i2c.writeto_mem(ADDR_MAG, REG_MAG_CFG_C, b'\x10')
        
        print("[1] Done.")
    except Exception as e:
        print("[1] Init Failed: {}".format(e))
    
    utime.sleep_ms(100) # 等待传感器内部电路稳定

def get_data_safe(i2c, name, addr, reg, scale):
    """
    安全读取并转换数据
    参数:
      name: 传感器名称 (用于调试)
      addr: 设备 I2C 地址
      reg:  数据起始寄存器
      scale: 灵敏度转换系数 (将 LSB 转换为物理单位)
    """
    try:
        # 连续读取 6 个字节 (X_L, X_H, Y_L, Y_H, Z_L, Z_H)
        data = i2c.readfrom_mem(addr, reg, 6)
        
        # --- 手动解析数据 (替代 struct 模块) ---
        # 1. 组合高低字节 (小端序 Little Endian)
        val_x = data[0] | (data[1] << 8)
        # 2. 处理有符号数 (Two's Complement): 若最高位为1，则减去 65536 转为负数
        if val_x & 0x8000: val_x -= 0x10000
        
        # 处理 Y 轴
        val_y = data[2] | (data[3] << 8)
        if val_y & 0x8000: val_y -= 0x10000
        
        # 处理 Z 轴
        val_z = data[4] | (data[5] << 8)
        if val_z & 0x8000: val_z -= 0x10000
        
        # --- 转换为物理单位并格式化 ---
        return "{:.2f}, {:.2f}, {:.2f}".format(
            val_x * scale, 
            val_y * scale, 
            val_z * scale
        )
    except Exception as e:
        # 捕获 I2C 通信错误，防止程序崩溃退出
        return "Err: {}".format(e)

# --- 主程序逻辑 ---
try:
    print("[0] Setup I2C...")
    i2c = machine.I2C(I2C_ID, freq=I2C_FREQ)
    
    # 初始化所有传感器
    init_sensors(i2c)
    
    print("\nReading Data (Super Safe Mode)... ")
    # 打印表头
    print("{:<25} | {:<25} | {:<25}".format("Accel (g)", "Gyro (dps)", "Mag (Gauss)"))
    
    # [关键操作] 主动回收垃圾内存，防止堆内存碎片化导致 MemoryError
    gc.collect()
    
    print("-" * 80)
    
    while True:
        # 1. 读取加速度 (灵敏度: 0.061 mg/LSB -> 换算成 g)
        s_acc = get_data_safe(i2c, "ACC", ADDR_IMU, REG_IMU_OUTX_L_A, 0.061/1000.0)
        
        # 2. 读取角速度 (灵敏度: 8.75 mdps/LSB -> 换算成 dps)
        s_gyr = get_data_safe(i2c, "GYR", ADDR_IMU, REG_IMU_OUTX_L_G, 8.75/1000.0)
        
        # 3. 读取磁场强度 (灵敏度: 1.5 mG/LSB -> 换算成 Gauss)
        s_mag = get_data_safe(i2c, "MAG", ADDR_MAG, REG_MAG_OUT_X_L, 1.5/1000.0)
        
        # 打印一行数据
        print("{:<25} | {:<25} | {:<25}".format(s_acc, s_gyr, s_mag))
        
        # 延时 200ms (约 5Hz 刷新率)
        utime.sleep_ms(200)

except Exception as e:
    print("FATAL CRASH: {}".format(e))
```

输出：

```python
=== START DEBUG ===
[0] Setup I2C...
[1] Init Sensors...
[1] Done.

Reading Data (Super Safe Mode)...
Accel                     | Gyro                      | Mag
--------------------------------------------------------------------------------
0.52, 0.08, -0.83         | -0.56, 0.25, 1.03         | -0.34, -0.52, 0.26
0.74, -0.05, -0.24        | 15.98, -18.82, -7.19      | -0.31, -0.59, 0.16
0.84, -0.07, -0.49        | 15.56, -5.90, 27.94       | -0.30, -0.60, 0.15
0.81, -0.06, -0.52        | -0.12, -14.01, -20.03     | -0.30, -0.59, 0.15
0.73, -0.09, -0.18        | -11.75, 12.22, 1.22       | -0.31, -0.60, 0.15
0.93, -0.13, -0.61        | 24.68, -50.96, 34.87      | -0.29, -0.60, 0.16
0.92, -0.08, -0.73        | -6.81, 3.88, -11.11       | -0.30, -0.60, 0.15
0.92, -0.11, -0.57        | 12.60, -52.44, 39.59      | -0.30, -0.59, 0.14
0.70, -0.10, -0.23        | 45.32, 16.79, -1.54       | -0.31, -0.59, 0.12
0.98, 0.02, -0.54         | -75.98, 44.40, 2.72       | -0.31, -0.59, 0.13
0.82, -0.29, -0.34        | 107.72, -72.42, -11.81    | -0.29, -0.61, 0.15
```



### 5、SPI测试

#### 磁力计开发板接线说明：

| **Sensor Pin** | **Board Pin** | **Function**  |
| -------------- | ------------- | ------------- |
| **SCL**        | **P412**      | SCK           |
| **SDA**        | **P411**      | MOSI          |
| **SA0/SDO**    | **P410**      | MISO          |
| **1 CS**       | **P413**      | CS (Software) |
| **3V3/GND**    | **3V3/GND**   | Power         |

#### 5.1：SPI 设备 ID 读取验证

 **目的**：验证 SPI 总线的基础通讯能力。通过手动控制片选 (CS) 引脚，发送读取命令，验证能否从传感器读取到预期的芯片 ID，从而确认 MOSI/MISO/SCK 连线及相位配置正确

```python
import machine
import utime
from machine import Pin

# --- 硬件配置 ---
SPI_ID = 1              # SPI1
SPI_BAUDRATE = 1000000  # 1MHz
CS_PIN_ID = 0x040D      # P413 (片选)

# --- 寄存器 ---
REG_WHO_AM_I = 0x0F     # ID 寄存器
CMD_READ = 0x80         # 读命令掩码

print("=== SPI ID Read Test (SPI ID ) ===")

try:
    # 1. 初始化 CS 引脚 (手动控制)
    cs = Pin(CS_PIN_ID, Pin.OUT)
    cs.value(1) # 默认拉高 (不选中)
    print("CS Pin initialized.")

    # 2. 初始化 SPI
    # Polarity=0, Phase=0 (Mode 0)
    spi = machine.SPI(SPI_ID, baudrate=SPI_BAUDRATE, polarity=0, phase=0)
    print("SPI Bus initialized.")
    utime.sleep_ms(100)

    # 3. 读取 ID
    print("Reading WHO_AM_I...")
    cs.value(0) # 选中设备
    spi.write(bytes([REG_WHO_AM_I | CMD_READ])) # 发送读命令
    data = spi.read(1) # 读取1字节
    cs.value(1) # 释放设备
    
    # 4. 结果验证
    if len(data) > 0:
        chip_id = data[0]
        print("Raw Data: 0x{:02X}".format(chip_id))
        # 注: LSM6DSV16X 预期 ID 为 0x70, 但有时因模式问题可能读到 0x60
    else:
        print("ERROR: No data received.")

except Exception as e:
    print("Fatal Error: {}".format(e))
```

输出：

```python
=== SPI ID Read Test (SPI ID ) ===
CS Pin initialized.
SPI Bus initialized.
Reading WHO_AM_I...
Raw Data: 0x70
```



#### 5.2：SPI 实时加速度数据读取

 **目的**：在确认 ID 读取成功的基础上，验证连续、多字节的 SPI 数据传输稳定性。此测试将持续读取 X/Y/Z 三轴加速度数据并转换为物理单位

```python
import machine
import utime
from machine import Pin

# --- Configuration (配置参数) ---
SPI_ID = 1              # 使用 SPI1 通道
SPI_BAUDRATE = 100000   # 波特率设为 100kHz (降低速度以确保杜邦线连接下的信号稳定性)
CS_PIN_ID = 0x040D      # 片选引脚 ID: P413 (用于手动控制 CS)

# Registers (寄存器地址)
REG_WHO_AM_I      = 0x0F  # 芯片 ID 寄存器
REG_CTRL1_XL      = 0x10  # 加速度计控制寄存器 (用于设置速率和量程)
REG_OUTX_L_A      = 0x28  # 加速度数据输出起始地址 (X轴低字节)
CMD_READ          = 0x80  # 读命令掩码 (SPI读取时，地址最高位 Bit 7 需置 1)

# --- 辅助函数：字节转整数 ---
def bytes_to_int16(low_byte, high_byte):
    """将两个字节转换为 16 位有符号整数 (小端序)"""
    val = low_byte | (high_byte << 8)
    # 处理符号位 (如果最高位为 1，则转为负数)
    if val & 0x8000:
        val -= 0x10000
    return val

# --- SPI Helper Class (SPI 传感器封装类) ---
class SPISensor:
    def __init__(self, spi, cs_pin):
        self.spi = spi
        self.cs = Pin(cs_pin, Pin.OUT)
        self.cs.value(1) # 初始化时拉高 CS (取消选中)，保持空闲状态
        
    def write_reg(self, reg, val):
        """写寄存器：拉低CS -> 发送地址+数据 -> 拉高CS"""
        self.cs.value(0)
        # 写操作：寄存器地址 Bit 7 置 0
        self.spi.write(bytes([reg & 0x7F, val]))
        self.cs.value(1)
        
    def read_reg(self, reg, length=1):
        """读寄存器：拉低CS -> 发送地址 -> 读取数据 -> 拉高CS"""
        self.cs.value(0)
        # 读操作：寄存器地址 Bit 7 置 1
        self.spi.write(bytes([reg | 0x80]))
        data = self.spi.read(length)
        self.cs.value(1)
        return data

# --- Main Logic (主程序逻辑) ---
print("=== SPI Real-World Data Test ===")

try:
    # 1. Init SPI (初始化 SPI 总线)
    # ST 传感器通常在 Mode 3 (Polarity=1, Phase=1) 下工作最稳定
    spi = machine.SPI(SPI_ID, baudrate=SPI_BAUDRATE, polarity=1, phase=1)
    sensor = SPISensor(spi, CS_PIN_ID)
    print("SPI Initialized at 100kHz, Mode 3.")
    utime.sleep_ms(100)

    # 2. Check ID (检查芯片 ID)
    # 读取 WHO_AM_I 寄存器 (即使读到 0x60 也不报错，仅打印出来供参考)
    id_val = sensor.read_reg(REG_WHO_AM_I)[0]
    print("Chip ID read: 0x{:02X} (Ignored)".format(id_val))

    # 3. Wake up Accelerometer (唤醒加速度计)
    print("Waking up sensor...")
    # 写入 0x03 到 CTRL1_XL:
    # Bit 3-0 (ODR_XL) = 0011 -> 输出速率 15Hz
    # Bit 5-4 (FS_XL)  = 00   -> 量程 2g
    sensor.write_reg(REG_CTRL1_XL, 0x03)
    utime.sleep_ms(200) # 等待传感器启动稳定

    # 4. Read Data Loop (循环读取数据)
    print("\nReading Accelerometer (Press Ctrl+C to stop)...")
    print("{:<20} | {:<20} | {:<20}".format("X (g)", "Y (g)", "Z (g)"))
    print("-" * 66)

    while True:
        # 连续读取 6 个字节 (X_L, X_H, Y_L, Y_H, Z_L, Z_H)
        # SPI 支持地址自动递增，所以只需指定起始地址即可
        data = sensor.read_reg(REG_OUTX_L_A, 6)
        
        # 解析原始数据并转换为物理单位 g
        # 灵敏度系数：在 2g 量程下，1 LSB = 0.061 mg = 0.000061 g
        x = bytes_to_int16(data[0], data[1]) * 0.061 / 1000.0
        y = bytes_to_int16(data[2], data[3]) * 0.061 / 1000.0
        z = bytes_to_int16(data[4], data[5]) * 0.061 / 1000.0
        
        # 格式化并打印输出
        print("{:<20.2f} | {:<20.2f} | {:<20.2f}".format(x, y, z))
        utime.sleep_ms(200)

except Exception as e:
    print("Error: {}".format(e))
```

输出：

```python
=== SPI Real-World Data Test ===
SPI Initialized at 100kHz, Mode 3.
Chip ID read: 0x60 (Ignored)
Waking up sensor...

Reading Accelerometer (Press Ctrl+C to stop)...
X (g)                | Y (g)                | Z (g)
------------------------------------------------------------------
-1.19                | 0.06                 | 0.01
1.39                 | 0.80                 | 0.06
1.39                 | 0.52                 | 0.20
-1.24                | 0.60                 | 0.11
1.39                 | 0.33                 | 0.05
0.70                 | 0.13                 | 0.02
-1.12                | 0.55                 | 0.00
0.27                 | 0.10                 | 0.00
-0.50                | 0.44                 | 0.02
-0.20                | 1.54                 | 0.02
0.23                 | 1.11                 | 0.02
1.01                 | -1.98                | 0.01
0.74                 | 0.26                 | 0.00
-0.90                | -1.96                | 0.00
```



### 6、DWT 微秒级高精度计时验证

 **目的**：验证移植代码中基于 Cortex-M DWT (Data Watchpoint and Trace) 单元实现的 `ticks_us()` 和 `ticks_cpu()` 函数。确认计时精度是否达到微秒级，以及延时函数 `sleep_us` 是否准确

```python
"""
更严谨的 DWT/utime 计时与 sleep_us 精度测试
Improved DWT/utime timing & sleep_us accuracy test
"""

import utime
from utime import ticks_diff


def list_utime_methods():
    print("Available methods in utime module:")
    try:
        methods = [attr for attr in dir(utime) if not attr.startswith('_')]
        print("  Methods:", methods)
    except Exception as e:
        print("  Could not list methods:", e)


def test_ticks_ms():
    print("\n[1] ticks_ms() basic test")
    try:
        start = utime.ticks_ms()
        utime.sleep_ms(100)
        end = utime.ticks_ms()
        elapsed = ticks_diff(end, start)
        print("  ticks_ms(): {} ms elapsed (target ~100ms)".format(elapsed))
        return True
    except Exception as e:
        print("  ERROR: ticks_ms() failed:", e)
        return False


def measure_cpu_mhz(interval_ms=100):
    """
    同一次 sleep 同时采样 ticks_us 与 ticks_cpu，反推出 CPU MHz。
    返回 (elapsed_us, elapsed_cpu, mhz)
    """
    print("\n[2] ticks_us() + ticks_cpu() cross-check (single interval)")
    try:
        start_us = utime.ticks_us()
        start_cpu = utime.ticks_cpu()

        utime.sleep_ms(interval_ms)

        end_cpu = utime.ticks_cpu()
        end_us = utime.ticks_us()

        elapsed_us = ticks_diff(end_us, start_us)
        elapsed_cpu = ticks_diff(end_cpu, start_cpu)

        # cycles/us = MHz（因为 1MHz = 1 cycle/us）
        mhz = (elapsed_cpu / elapsed_us) if elapsed_us > 0 else 0.0

        print("  Interval: {} ms".format(interval_ms))
        print("  ticks_us():  {} us elapsed".format(elapsed_us))
        print("  ticks_cpu(): {} cycles elapsed".format(elapsed_cpu))
        print("  Derived CPU frequency: {:.6f} MHz".format(mhz))

        # 再给一个“用该 MHz 预测 cycles”的一致性检查
        expected_cpu = int(elapsed_us * mhz)
        err_cycles = elapsed_cpu - expected_cpu
        err_us = err_cycles / mhz if mhz > 0 else 0.0
        err_percent = (abs(err_cycles) / expected_cpu * 100) if expected_cpu > 0 else 0.0

        print("  Expected cycles (us * MHz): {}".format(expected_cpu))
        print("  Error: {} cycles (~{:.3f} us), {:.6f}%".format(err_cycles, err_us, err_percent))

        return elapsed_us, elapsed_cpu, mhz

    except AttributeError as e:
        print("  ERROR: ticks_us/ticks_cpu not available:", e)
        return None, None, None
    except Exception as e:
        print("  ERROR in cross-check:", e)
        return None, None, None


def measure_overhead_cycles(samples=2000):
    """
    测量“只读 start/end + ticks_diff”等流程的开销（不含 sleep_us）。
    返回 avg_overhead_cycles
    """
    try:
        total = 0
        for _ in range(samples):
            s = utime.ticks_cpu()
            e = utime.ticks_cpu()
            total += ticks_diff(e, s)
        return total / samples
    except Exception:
        return None


def measure_call_overhead_sleep_us_zero(samples=2000):
    """
    尝试测量调用 sleep_us(0) 的额外开销（如果实现支持 0）。
    返回 avg_cycles；如果不支持则返回 None。
    """
    try:
        total = 0
        for _ in range(samples):
            s = utime.ticks_cpu()
            utime.sleep_us(0)
            e = utime.ticks_cpu()
            total += ticks_diff(e, s)
        return total / samples
    except Exception:
        return None


def test_sleep_us_accuracy(mhz, delays=(1, 10, 50, 100, 500), reps=500):
    print("\n[3] sleep_us() accuracy test (using ticks_cpu, averaged)")

    if mhz is None or mhz <= 0:
        print("  SKIP: CPU MHz not available (mhz = {})".format(mhz))
        return

    # 基础测量开销（读两次 ticks_cpu 的开销）
    base_overhead = measure_overhead_cycles(samples=2000)
    if base_overhead is None:
        print("  ERROR: could not measure overhead (ticks_cpu missing?)")
        return

    # 尝试测量 sleep_us(0) 的开销（如果支持）
    call_overhead = measure_call_overhead_sleep_us_zero(samples=2000)

    print("  Derived CPU: {:.6f} MHz".format(mhz))
    print("  Base overhead (ticks_cpu read pair): {:.2f} cycles (~{:.3f} us)".format(
        base_overhead, base_overhead / mhz
    ))
    if call_overhead is not None:
        print("  sleep_us(0) call cost: {:.2f} cycles (~{:.3f} us)".format(
            call_overhead, call_overhead / mhz
        ))
        # 用 sleep_us(0) 作为更贴近“调用 sleep_us”的开销基线
        overhead_to_subtract = call_overhead
        overhead_name = "sleep_us(0)"
    else:
        # 退化：只能扣掉最基础的测量开销
        overhead_to_subtract = base_overhead
        overhead_name = "base"

    print("  Overhead baseline used for correction: {}".format(overhead_name))
    print("  Repetitions per delay: {}".format(reps))

    print("\n  Delay(us) | avg(us) | corrected(us) | +err(us)")
    print("  --------- | ------ | ------------ | -------")

    for d in delays:
        try:
            total_cycles = 0
            for _ in range(reps):
                s = utime.ticks_cpu()
                utime.sleep_us(d)
                e = utime.ticks_cpu()
                total_cycles += ticks_diff(e, s)

            avg_cycles = total_cycles / reps
            avg_us = avg_cycles / mhz
            corrected_us = (avg_cycles - overhead_to_subtract) / mhz
            err_us = corrected_us - d

            print("  {:9d} | {:6.2f} | {:12.2f} | {:+7.2f}".format(
                d, avg_us, corrected_us, err_us
            ))

        except Exception as e:
            print("  {:9d} | ERROR: {}".format(d, e))


def quick_monotonicity_check(samples=2000):
    """
    简单检查 ticks_us 单调性（不做严格证明，只做粗检测）
    """
    print("\n[4] ticks_us() monotonic sanity check")
    try:
        last = utime.ticks_us()
        backwards = 0
        for _ in range(samples):
            cur = utime.ticks_us()
            # 允许回绕：用 ticks_diff 判断“是否真的倒退”
            if ticks_diff(cur, last) < 0:
                backwards += 1
            last = cur
        print("  Samples: {}, backwards detected (should be 0 normally): {}".format(samples, backwards))
    except Exception as e:
        print("  SKIP/ERROR:", e)


def main():
    print("Improved DWT high precision microsecond timing test")
    print("=" * 50)

    list_utime_methods()

    ok = test_ticks_ms()
    if not ok:
        return

    elapsed_us, elapsed_cpu, mhz = measure_cpu_mhz(interval_ms=100)

    # sleep_us 精度测试：用 ticks_cpu + 平均 + 扣开销
    test_sleep_us_accuracy(
        mhz=mhz,
        delays=(1, 10, 50, 100, 500),
        reps=500
    )

    quick_monotonicity_check(samples=2000)

    print("\nAll tests completed!")


if __name__ == "__main__":
    main()

```

输出：

```python
Improved DWT high precision microsecond timing test
==================================================
Available methods in utime module:
  Methods: ['sleep', 'sleep_ms', 'sleep_us', 'ticks_cpu', 'ticks_diff', 'ticks_ms', 'ticks_us']

[1] ticks_ms() basic test
  ticks_ms(): 100 ms elapsed (target ~100ms)

[2] ticks_us() + ticks_cpu() cross-check (single interval)
  Interval: 100 ms
  ticks_us():  100077 us elapsed
  ticks_cpu(): 48032092 cycles elapsed
  Derived CPU frequency: 479.951357 MHz
  Expected cycles (us * MHz): 48032092
  Error: 0 cycles (~0.000 us), 0.000000%

[3] sleep_us() accuracy test (using ticks_cpu, averaged)
  Derived CPU: 479.951357 MHz
  Base overhead (ticks_cpu read pair): 2559.85 cycles (~5.334 us)
  sleep_us(0) call cost: 4783.85 cycles (~9.967 us)
  Overhead baseline used for correction: sleep_us(0)
  Repetitions per delay: 500

  Delay(us) | avg(us) | corrected(us) | +err(us)
  --------- | ------ | ------------ | -------
          1 |  11.08 |         1.11 |   +0.11
         10 |  20.10 |        10.13 |   +0.13
         50 |  60.11 |        50.15 |   +0.15
        100 | 110.05 |       100.08 |   +0.08
        500 | 510.26 |       500.29 |   +0.29

[4] ticks_us() monotonic sanity check
  Samples: 2000, backwards detected (should be 0 normally): 0

All tests completed!
```



### 7、系统时钟与唯一ID读取测试

 **目的**：验证 **CPU 主频** 是否配置为预期的 480MHz，确认 **芯片唯一 ID (Unique ID)** 读取接口是否正常（用于设备量产识别），并验证软复位功能的稳定性。

```python
"""
测试系统信息与运行频率 (无需 binascii 模块)
Test System Information and Frequency (No binascii version)
"""
import machine
import utime

def test_system_info():
    print("=" * 40)
    print("System Information Test")
    print("=" * 40)
    
    # --- 测试 1: 获取并验证 CPU 频率 ---
    try:
        # 获取当前 CPU 运行频率
        freq = machine.freq()
        print("CPU Frequency: {} Hz".format(freq))
        
        # 检查频率是否符合瑞萨 RA8D1 的标称值 (480MHz)
        if freq == 480000000:
            print("  [PASS] Frequency matches RA8D1 spec (480MHz).") # 测试通过：频率符合规格
        else:
            print("  [WARN] Frequency mismatch! Expected 480000000.") # 警告：频率不匹配
    except AttributeError:
        # 如果固件未实现 machine.freq() 方法，捕获异常并提示
        print("  [WARN] machine.freq() not implemented.")

    # --- 测试 2: 获取芯片唯一 ID (Unique ID) ---
    try:
        # 获取芯片的唯一标识符 (通常是二进制字节串)
        uid = machine.unique_id()
        print("Unique ID (raw): {}".format(uid))
        
        if uid:
            # 手动实现将 bytes 转换为十六进制字符串 (替代 binascii.hexlify)
            # 逻辑：遍历 uid 中的每个字节 b，将其格式化为 2 位十六进制数 ('{:02x}')，最后拼接成字符串
            uid_hex = "".join(["{:02x}".format(b) for b in uid])
            
            print("Unique ID (hex): {}".format(uid_hex))
            print("  [PASS] Unique ID read successfully.") # 测试通过：成功读取 ID
        else:
            print("  [FAIL] Unique ID is empty.") # 失败：读取到的 ID 为空
            
    except AttributeError:
        # 如果固件未实现 machine.unique_id() 方法，捕获异常并提示
        print("  [WARN] machine.unique_id() not implemented.")
        
    # --- 提示进行软复位测试 ---
    print("\nPerform Soft Reset Test?") # 提示：执行软复位测试？
    print("Only run this if REPL is stable.") # 注意：仅在 REPL (交互式命令行) 稳定时才运行此操作

if __name__ == "__main__":
    # 如果作为主程序运行，则执行测试函数
    test_system_info()
```

输出：

```python
========================================
System Information Test
========================================
CPU Frequency: 480000000 Hz
  [PASS] Frequency matches RA8D1 spec (480MHz).
Unique ID (raw): b'\x97|\x05C310XSF\xaf\xa7\xea.KN'
Unique ID (hex): 977c0543333130585346afa7ea2e4b4e
  [PASS] Unique ID read successfully.

Perform Soft Reset Test?
Only run this if REPL is stable.
>>>

Soft reboot
MicroPython 2762fe680a-dirty on 2025-11-13; RA8D1-minimal with RA8D1
Type "help()" for more information.
>>>
```





### 8、ADC/DAC测试

**目的：** 验证开发板的 **DAC（数模转换，输出电压）** 和 **ADC（模数转换，读取电压）** 驱动功能是否正常，同时检查两者之间的硬件连接（回路）是否导通且精准。

**逻辑：**

1. **初始化**：使用整数 ID 分别初始化 DAC 输出引脚（P014）和 ADC 输入引脚（P004）。
2. **电压扫描**：设定一组 8 位数值（0, 64, 128, 192, 255），分别对应 0V 到 3.3V 的不同电压等级。
3. **读写验证**：
   - DAC 输出指定数值的电压。
   - ADC 读取该电压值。
   - 程序通过数学公式将 ADC 的原始读数（0-65535）换算为电压值。
   - 最后对比“实测电压”与“理论电压”，如果两者接近，说明软硬件工作正常。

```python
import machine
import utime
from machine import ADC, DAC, Pin

# --- 配置参数 ---
# 使用整数 ID 来配置引脚，避免字符串解析问题
# P014 (DAC) 对应 Port 0, Pin 14, 整数 ID 为 14
DAC_PIN_ID = 14  
# P004 (ADC) 对应 Port 0, Pin 4,  整数 ID 为 4
ADC_PIN_ID = 4   

print("=== ADC & DAC Loopback Test ===")
print("Please connect P014 (DAC) to P004 (ADC)")
# 等待 2 秒，给用户时间检查接线
utime.sleep(2) 

try:
    # 1. 初始化 DAC (数模转换器)
    print("Initializing DAC on P014 (ID={})...".format(DAC_PIN_ID))
    dac = DAC(DAC_PIN_ID)
    
    # 2. 初始化 ADC (模数转换器)
    print("Initializing ADC on P004 (ID={})...".format(ADC_PIN_ID))
    adc = ADC(id=ADC_PIN_ID)
    
    print("Starting voltage sweep test...")
    print("-" * 45)
    print("{:<10} | {:<15} | {:<15}".format("Set (8bit)", "Read (16bit)", "Calc Voltage"))
    print("-" * 45)

    # 3. 扫描测试：输出从 0V 到 3.3V 的电压
    # MicroPython 的 DAC 是 8 位精度 (值范围 0-255)
    # 我们选取 5 个测试点进行验证
    for val in [0, 64, 128, 192, 255]:
        # 写入 DAC 数值，引脚输出对应电压
        dac.write(val)
        
        # 短暂延时，等待电压稳定
        utime.sleep_ms(10)
        
        # 读取 ADC 数值 (MicroPython ADC 统一为 16 位精度，范围 0-65535)
        read_raw = adc.read_u16()
        
        # 计算实际测量电压 (假设参考电压为 3.3V)
        # 公式：(ADC读数 / 65535) * 3.3V
        voltage = (read_raw * 3.3) / 65535.0
        
        # 计算理论预期电压
        # 公式：(DAC设置值 / 255) * 3.3V
        expected = (val * 3.3) / 255.0
        
        # 打印对比结果：设置值 | 读取原始值 | 实测电压 (预期电压)
        print("{:<10d} | {:<15d} | {:.2f}V (Exp: {:.2f}V)".format(val, read_raw, voltage, expected))
        
        # 每次测试间隔 200ms
        utime.sleep_ms(200)

    print("-" * 45)
    print("Test Complete.")

except Exception as e:
    # 如果发生错误（如引脚无效），打印错误信息
    print("Fatal Error: {}".format(e))

print("=== End ===")
```

输出：

```python
=== ADC & DAC Loopback Test ===
Please connect P014 (DAC) to P004 (ADC)
Initializing DAC on P014 (ID=14)...
Initializing ADC on P004 (ID=4)...
Starting voltage sweep test...
---------------------------------------------
Set (8bit) | Read (16bit)    | Calc Voltage
---------------------------------------------
0          | 0               | 0.00V (Exp: 0.00V)
64         | 16419           | 0.83V (Exp: 0.83V)
128        | 32871           | 1.66V (Exp: 1.66V)
192        | 49387           | 2.49V (Exp: 2.48V)
255        | 65518           | 3.30V (Exp: 3.30V)
---------------------------------------------
Test Complete.
=== End ===
```



### 9、uart测试

#### 测试用例(1)

```python
import machine
import utime

# --- Configuration ---
# You changed hardware to SCI9 (g_uart1 in FSP)
# TX Pin: P209
# RX Pin: P208
UART_ID = 1
BAUDRATE = 115200

print("=== UART Loopback Test (SCI9) ===")
print("Configuration: UART({}) Baudrate={}".format(UART_ID, BAUDRATE))
# [Updated Instruction] Reflecting your new pin config
print("Instruction: Please connect P209 (TX) to P208 (RX) with a jumper wire.")
utime.sleep(2)  # Wait for user to check wiring

try:
    # 1. Initialize UART
    # Note: Pins are configured by FSP (P209/P208), no need to specify in Python
    uart = machine.UART(UART_ID, baudrate=BAUDRATE)
    print("UART initialized successfully.")

    # 2. Clear garbage data
    if uart.any():
        dummy = uart.read()
        print("Cleared {} bytes from buffer.".format(len(dummy)))

    # 3. Test: Basic Write and Read
    message = b"MicroPython SCI9 Test"
    print("-" * 30)
    print("Test 1: Basic Loopback")
    print("Sending: {}".format(message))
    
    # Write data
    count = uart.write(message)
    print("Bytes written: {}".format(count))
    
    # Wait for transmission (SCI9 is fast, but we wait to be safe)
    utime.sleep_ms(100)
    
    # Check receive buffer
    avail = uart.any()
    print("Bytes available: {}".format(avail))
    
    if avail > 0:
        received = uart.read()
        print("Received: {}".format(received))
        
        if received == message:
            print("Result: PASS")
        else:
            print("Result: FAIL (Content mismatch)")
            print("Exp: {}".format(message))
            print("Got: {}".format(received))
    else:
        print("Result: FAIL (No data received)")
        print("Hint: Check connection between P209 and P208.")

    # 4. Test: Large Packet (Stress Test)
    print("-" * 30)
    print("Test 2: Throughput / Buffer")
    
    # Send 128 bytes of 'A'
    large_packet = b"A" * 128
    uart.write(large_packet)
    utime.sleep_ms(200)
    
    rec_large = uart.read()
    rec_len = len(rec_large) if rec_large else 0
    print("Sent 128 bytes, Received {} bytes".format(rec_len))
    
    if rec_len == 128:
        print("Result: PASS")
    else:
        print("Result: FAIL (Data loss or buffer overflow)")

except Exception as e:
    print("Fatal Error: {}".format(e))

print("=== End ===")
```

输出：

```python
=== UART Loopback Test (SCI9) ===
Configuration: UART(1) Baudrate=115200
Instruction: Please connect P209 (TX) to P208 (RX) with a jumper wire.
UART initialized successfully.
------------------------------
Test 1: Basic Loopback
Sending: b'MicroPython SCI9 Test'
Bytes written: 21
Bytes available: 21
Received: b'MicroPython SCI9 Test'
Result: PASS
------------------------------
Test 2: Throughput / Buffer
128
Sent 128 bytes, Received 128 bytes
Result: PASS
=== End ===
```



#### 测试代码(2)

```python
import machine
import utime

# --- Configuration ---
# UART(1) maps to SCI9 (P209/TX, P208/RX)
UART_ID = 1
BAUDRATE = 115200
BUFFER_SIZE = 256

print("=== UART Functionality Test ===")
print("Config: UART({}) @ {} baud".format(UART_ID, BAUDRATE))
print("Setup: Please connect P209 (TX) to P208 (RX)")
utime.sleep(1)

try:
    # 1. Initialize
    print("\n[1] Initializing UART...")
    uart = machine.UART(UART_ID, baudrate=BAUDRATE)
    print("UART object created.")

    # 2. Write Test (Bytes)
    print("\n[2] Testing Write (Bytes)...")
    # Note: Using bytes literal b'...' directly to avoid .encode() error
    msg = b"Hello RA8D1 UART!"
    count = uart.write(msg)
    print("Sent {} bytes: {}".format(count, msg))
    
    if count != len(msg):
        print("FAIL: Sent count mismatch!")
    
    # Wait for transmission and reception (loopback)
    utime.sleep_ms(50)

    # 3. Read Test
    print("\n[3] Testing Read...")
    if uart.any():
        rx_data = uart.read()
        print("Received: {}".format(rx_data))
        
        if rx_data == msg:
            print("PASS: Data matches exactly.")
        else:
            print("FAIL: Data mismatch.")
            print("Expected: {}".format(msg))
            print("Actual:   {}".format(rx_data))
    else:
        print("FAIL: No data received (Check wiring P209 <-> P208)")

    # 4. Stress Test (Ring Buffer)
    print("\n[4] Stress Test (100 bytes)...")
    # Generate byte array 0x00 - 0x63
    tx_stress = bytearray([i for i in range(100)])
    
    uart.write(tx_stress)
    utime.sleep_ms(100) # Give it time
    
    rx_stress = uart.read()
    print("Sent 100 bytes, Received {} bytes".format(len(rx_stress) if rx_stress else 0))
    
    if rx_stress == tx_stress:
        print("PASS: Stress test successful.")
    else:
        print("FAIL: Stress test failed.")

    # 5. Deinit
    print("\n[5] Cleanup...")
    uart.deinit()
    print("UART De-initialized.")

except Exception as e:
    print("FATAL ERROR: {}".format(e))

print("\n=== Test Finished ===")
```



```python
=== UART Functionality Test ===
Config: UART(1) @ 115200 baud
Setup: Please connect P209 (TX) to P208 (RX)

[1] Initializing UART...
UART object created.

[2] Testing Write (Bytes)...
Sent 17 bytes: b'Hello RA8D1 UART!'

[3] Testing Read...
Received: b'Hello RA8D1 UART!'
PASS: Data matches exactly.

[4] Stress Test (100 bytes)...
100
Sent 100 bytes, Received 100 bytes
PASS: Stress test successful.

[5] Cleanup...
UART De-initialized.

=== Test Finished ===
```
